{"body":"\r\n# Roque\r\n\r\n_pronounced \"raw-queue\"_\r\n\r\nRoque is an event & work queueing framework for .Net, made simple.\r\n\r\nIt sits on top of the C# abstractions you know (plain old C# events and methods), and uses [Redis](http://redis.io/) behind the scenes to make them work in an async, transparent, distributed, scalable, decoupled and failure-proof way.\r\n\r\nMessage queueing doesn't get simpler than this!\r\n\r\n> Really?? ... show me!\r\n\r\n## Example 1: Image Processing\r\n\r\nLets say we have a website and we want to build thumbnails for uploaded pics, that's a time-consuming operation we can't perform during the lifetime of web request.\r\n\r\n1- Create a service interface.\r\n\r\n``` csharp\r\n\r\n    public interface IImageProcessor {\r\n        void CreateThumbnail(string filename, int width, int height, AlgorithmOptions options);\r\n    }\r\n``` \r\n\r\n2- Use it on your application:\r\n\r\n``` csharp\r\n\r\n    public class ImageBiz {\r\n        IImageProcessor ImageProcessor = RoqueProxyGenerator.Create<IImageProcessor>(\"images\");\r\n        public void ImageUploaded(filename){\r\n            ImageProcessor.CreateThumbnail(filename, 160, 120, new AlgorithmOptions { Quality=0.7 });\r\n        }\r\n    }\r\n``` \r\n\r\nNote: add references to Roque.Core and Roque.Redis assemblies to your project.\r\n\r\n3- Config a redis-based queue named \"images\":\r\n\r\n``` xml\r\n\r\n    <?xml version=\"1.0\"?>\r\n    <configuration>\r\n      <configSections>\r\n        <section name=\"roque\" type=\"Cinchcast.Roque.Core.Configuration.Roque, Roque.Core\"/>\r\n      </configSections>\r\n      <roque>\r\n        <queues>\r\n          <queue name=\"images\" type=\"Cinchcast.Roque.Redis.RedisQueue, Roque.Redis\">\r\n            <settings>\r\n              <setting key=\"host\" value=\"localhost\"/>\r\n              <!-- Optional, if not specified default Redis port is used: 6379 -->\r\n              <setting key=\"port\" value=\"6379\"/> \r\n            </settings>\r\n          </queue>\r\n        </queues>\r\n      </roque>\r\n    </configuration>\r\n```\r\n\r\nThat's it. You're already enqueuing jobs!, let's set up a worker, hurry up!:\r\n\r\n4- Implement your image processor service:\r\n\r\n``` csharp\r\n\r\n    public class ImageProcessor : IImageProcessor {\r\n        public void CreateThumbnail(string filename, int width, int height, AlgorithmOptions options = null){\r\n            // a time-consuming task, eg: resize the image and save it adding a suffix\r\n            throw new NotImplementedException();\r\n        }\r\n    }\r\n``` \r\n\r\n5- Install Roque service on a machine (with access to your Redis server).\r\n\r\n6- On the same folder of roque.exe drop the assembly(ies) containing IImageProcessor interface and ImageProcessor class.\r\n\r\n7- On the worker Roque.exe.config:\r\n\r\n``` xml\r\n\r\n    <?xml version=\"1.0\"?>\r\n    <configuration>\r\n      <configSections>\r\n        <section name=\"roque\" type=\"Cinchcast.Roque.Core.Configuration.Roque, Roque.Core\"/>\r\n      </configSections>\r\n      <roque>\r\n        <queues>\r\n          <queue name=\"images\" type=\"Cinchcast.Roque.Redis.RedisQueue, Roque.Redis\">\r\n            <settings>\r\n              <setting key=\"host\" value=\"localhost\"/>\r\n            </settings>\r\n          </queue>\r\n        </queues>\r\n        <workers>\r\n          <!-- a worker poping jobs from \"images\" queue --> \r\n          <worker name=\"images\" queue=\"images\" autoStart=\"true\"/>\r\n        </workers>    \r\n      </roque>\r\n      <castle>\r\n        <components>\r\n          <!-- using Castle Windsor to tell Roque what image processing service to use. type name must be fully qualified --> \r\n          <component service=\"Acme.Images.IImageProcessor\" type=\"Acme.Images.ImageProcessor, Acme.Images\"/>\r\n        </components>\r\n      </castle>\r\n    </configuration>\r\n```\r\n\r\n8- Start Roque Service to start processing images!\r\n\r\n(or you can roque.exe from a console, use: roque.exe /debug to attach your VisualStudio and debug your image processor)\r\n\r\nYou're done, now you can start adding more workers to get automatic load balancing by repeating steps 5 to 8.\r\n\r\nTo check the status of your queues you can run: ```roque.exe status```\r\n\r\n    C:\\>roque status /maxage=10 /maxlength=500000\r\n    Redis send-pump is starting\r\n    roque Information: 0 : [REDIS] connected to localhost:6379\r\n    Queue images has 262570 pending jobs. Next job was created < 1sec ago.\r\n    Queue audiofiles has 3342 pending jobs. Next job was created 12sec ago. [TOO OLD]\r\n    Queue zipping is empty.\r\n    ERROR: 1 queue have too old pending jobs\r\n\r\nrun roque.exe without arguments to see al options.\r\n\r\n\r\n> That's awesome! but I want events, I need decoupling, I want multiple and easy to add/replace/remove subscribers. But I don't want to read books on [Message Queues](http://goo.gl/wipxw).\r\n\r\n(If you wonder what's the difference check the queue diagrams below showing a work queue and a pub/sub queue)\r\n\r\n## Example 2: Website User Sign-up post tasks.\r\n\r\nLet's change the approach, let's suppose we want to perform several differnt tasks each time a user signs up. These tasks include creating a thumbnail of users profile pic, and sending a welcome email. (we could add logging, stats, analytics, etc.)\r\n\r\nWe don't want to clutter our user entity with the execution of this tasks. We already know a good solution to this problem: events.\r\n\r\n1- Create an event-raising interface.\r\n\r\n``` csharp\r\n\r\n    public interface IUserEvents {\r\n        event EventHandler<UserEventArgs> UserSignedUp;\r\n    }\r\n``` \r\n\r\n2- Throw events on your application\r\n\r\n``` csharp\r\n\r\n    public class UserBiz : IUserEvents {\r\n\r\n        public event EventHandler<UserEventArgs> UserSignedUp;\r\n\r\n        public void SignUp(string username, string password, string email) {\r\n\r\n            // TODO: insert the user in my database\r\n\r\n            var handler = UserSignedUp;\r\n            if (handler != null){\r\n                handler(this, new UserEventArgs(username, email));\r\n            }\r\n\r\n            // TIP: if you want you can save a few lines writting an extension method for Exception\r\n            // UserSignedUp.Raise(new UserEventArgs(username, email));\r\n        }\r\n    }\r\n\r\n    public class BizEventsInitializer {\r\n        // call this on app startup\r\n        public void Init() {\r\n            // make all events on IUserEvents raised by this instance available for remote subscription\r\n            RoqueEventBroadcaster.SubscribeToAll<IUserEvents(UserBiz.Instance);\r\n        }\r\n    }\r\n``` \r\n\r\n3- Config redis-based events queue:\r\n\r\n``` xml\r\n\r\n    <?xml version=\"1.0\"?>\r\n    <configuration>\r\n      <configSections>\r\n        <section name=\"roque\" type=\"Cinchcast.Roque.Core.Configuration.Roque, Roque.Core\"/>\r\n      </configSections>\r\n      <roque>\r\n        <queues>\r\n          <!-- Reserved name _events is used by default by RoqueEventBroadcaster -->\r\n          <queue name=\"_events\" type=\"Cinchcast.Roque.Redis.RedisQueue, Roque.Redis\">\r\n            <settings>\r\n              <setting key=\"host\" value=\"localhost\"/>\r\n            </settings>\r\n          </queue>\r\n        </queues>\r\n      </roque>\r\n    </configuration>\r\n```\r\n\r\nYour website is ready!, You're events are available, they'll get in your queues as soon as you add subscribers for them.\r\n\r\nNote: If no subscribers are found for an event, nothing is sent to Redis. You _events queue will always be empty (it won't even exist on Redis), as events never get directly enqueued, they get broadcasted to other queues.\r\n\r\n4- Add some subscribers:\r\n\r\n``` csharp\r\n\r\n    public class ThumbnailCreator {\r\n        public void SubscribeTo(IUserEvents userEvents) {\r\n            userEvents.UserSignedUp+= UserEvents_UserSignedUp;\r\n        }\r\n        public void UserEvents_UserSignedUp(object sender, UserEventArgs args) {\r\n            // let's reuse or image processing service here\r\n            new ImageProcessor().CreateThumbnail(\"pics/\"+args.Username+\".jpg\", 160, 120);\r\n        }\r\n    }\r\n```\r\n\r\n``` csharp\r\n\r\n    public class UserGreeter {\r\n        public void SubscribeTo(IUserEvents userEvents) {\r\n            userEvents.UserSignedUp+= UserEvents_UserSignedUp;\r\n        }\r\n        public void UserEvents_UserSignedUp(object sender, UserEventArgs args) {\r\n            MailSender.SendWelcomeEmail(args.Username, args.Email);\r\n        }\r\n    }\r\n```\r\n\r\n5- Install Roque service on a machine (if you didn't before).\r\n\r\n6- On the same folder of roque.exe drop the assembly(ies) containing IUserEvents interface and your ThumbnailCreator and UserGreeter classes.\r\n\r\n7- On Roque.exe.config:\r\n\r\n``` xml\r\n\r\n    <?xml version=\"1.0\"?>\r\n    <configuration>\r\n      <configSections>\r\n        <section name=\"roque\" type=\"Cinchcast.Roque.Core.Configuration.Roque, Roque.Core\"/>\r\n      </configSections>\r\n      <roque>\r\n        <queues>\r\n          <queue name=\"images\" type=\"Cinchcast.Roque.Redis.RedisQueue, Roque.Redis\">\r\n            <settings>\r\n              <setting key=\"host\" value=\"localhost\"/>\r\n            </settings>\r\n          </queue>\r\n          <queue name=\"greetings\" type=\"Cinchcast.Roque.Redis.RedisQueue, Roque.Redis\">\r\n            <settings>\r\n              <setting key=\"host\" value=\"localhost\"/>\r\n            </settings>\r\n          </queue>\r\n        </queues>\r\n        <workers>\r\n          <!-- a worker poping jobs from \"images\" queue --> \r\n          <worker name=\"images\" queue=\"images\" autoStart=\"true\">\r\n            <subscribers>\r\n                <!-- all events that ThumbnailCreator subscribes to will be broadcasted to this worker's queue (images) --> \r\n                <subscriber type=\"Acme.Images.ThumbnailCreator, Acme.Images\"/>\r\n            </subscribers>\r\n          </worker>\r\n          <!-- a worker poping jobs from \"greettings\" queue --> \r\n          <worker name=\"greetings\" queue=\"greetings\" autoStart=\"true\">\r\n            <subscribers>\r\n                <!-- all events that UserGreeter subscribes to will be broadcasted to this worker's queue (greetings) --> \r\n                <subscriber type=\"Acme.Messaging.UserGreeter, Acme.Messaging\"/>\r\n            </subscribers>\r\n          </worker>\r\n        </workers>    \r\n      </roque>\r\n    </configuration>\r\n```\r\n\r\nNow this requires some explanation. What I'm saying here is, create 2 separate queues, with a worker listening on each queue.\r\n\r\nEach worker has a subscriber on it. Roque detects all events a subscriber is attached to (using interceptors on event handlers). That allows Roque to broadcast each event to all queues where there as least one worker, with a subscriber interested on this specific event. \r\n\r\nThis means Roque routes event messages automatically for you! Efficiently and without further configuration.\r\n\r\nOn the publisher side (eg. your website) a lists of subscribed queues is mantained and cached, if a new type of subscriber is found in any worker cache clear request is sent with a Redis PUB/SUB message.\r\n\r\nThis means you can just drop a new subscriber at any worker and your website(s) will immediately start sending the events you expect (and nothing more!).\r\n\r\n8- Start (or restart) Roque Service.\r\n\r\nNow you can check the status of your queues and you should see the \"user signed up\" event being copied to both queues:\r\n\r\n    C:\\>roque status\r\n    Redis send-pump is starting\r\n    roque Information: 0 : [REDIS] connected to localhost:6379\r\n    Queue images has 14 pending jobs. Next job was created 4sec ago.\r\n    Queue greetings has 434 pending jobs. Next job was created 1min 12sec ago.\r\n\r\n\r\nNote: This example seems to show that my mail sender is not keeping the pace, I might have to add more workers on the greetings queue, or check the speed of my SMTP server.\r\n\r\nYou can check event subscriptions by running ```roque.exe events```\r\n\r\n    C:\\>roque events\r\n    Redis send-pump is starting\r\n    roque Information: 0 : [REDIS] connected to localhost:6379\r\n    Queue _events has 1 event with subscribers\r\n       Acme.MySite.Biz.IUserEvents:UserSignedUp is observed by images, greetings\r\n\r\n## Triggers\r\n\r\nYou can configure triggers on your workers to enqueue specific jobs (a method call) based on different type of events. Custom triggers can be created, Roque includes a Schedule Trigger.\r\n\r\nTriggers only work with Redis based queues.\r\n\r\nRedundancy: If you configure the same trigger (same name) on multiple workers they coordinate to give you redundancy (don't worry, you won't get duplicated jobs).\r\n\r\n### Schedule Trigger\r\n\r\nSchedule trigger accept schedules using [cron syntax](http://en.wikipedia.org/wiki/Cron) (```* , - /``` characters are supported). \r\n\r\nWhen the time comes a method call job will be enqueued. Example configuration:\r\n\r\n``` xml\r\n\r\n    <roque>\r\n        <queues>\r\n            <queue name=\"main\" type=\"Cinchcast.Roque.Redis.RedisQueue, Roque.Redis\">\r\n                <settings>\r\n                    <setting key=\"host\" value=\"localhost\"/>\r\n                </settings>\r\n            </queue>\r\n        </queues>\r\n        <triggers>\r\n            <!-- check that logging is working every 5 minutes, from mon to fri --> \r\n            <!-- using optional JSON serialized argument, otherwise the method must be parameter-less --> \r\n            <trigger name=\"CheckTrace\" type=\"Cinchcast.Roque.Triggers.ScheduleTrigger, Roque.Triggers\" \r\n                     queue=\"main\" \r\n                     targetTypeFullName=\"Cinchcast.Roque.Common.Trace, Roque.Common.Services\"\r\n                     targetMethodName=\"TraceInformationString\" \r\n                     targetArgument=\"'testing...'\">\r\n                <settings>\r\n                    <!-- cron syntax, if this is new for you, you can use http://www.abunchofutils.com/utils/developer/cron-expression-helper/ --> \r\n                    <setting key=\"schedule\" value=\"*/5 * * * 1-5\" />\r\n                </settings>\r\n            </trigger>\r\n        </triggers>\r\n    </roque>\r\n\r\n```\r\n\r\nYou can check the state of all triggers by running ```roque.exe triggers```\r\n\r\n### FileWatcher Trigger\r\n\r\nComing Soon. Pull requests are welcome.\r\n\r\n## Requirements\r\n\r\n- Microsoft .Net Framework 4.0\r\n- Redis\r\n\r\n## Installing\r\n\r\n### Producer side (your application)\r\n\r\nRoque is available on the official Nuget gallery: https://nuget.org/packages/Roque\r\n\r\nThe package will add roque default configuration to your web|app.config.\r\n\r\n### Consumer side (workers)\r\n\r\nOn worker projects (containing service or subscriber classes) you can install Roque.Worker nuget package.\r\nThen you can then run roque in 3 ways:\r\n\r\n- Console mode (using ```Roque-Work``` or ```Roque-Work-Debug``` on VisualStudio Package Manager Console)\r\n- Install it as a service (using [SC](http://support.microsoft.com/kb/251192))\r\n- Run embedded in your app with: ```new WorkerHost().Start();```\r\n\r\nFor detailed instructions on creating and deploying workers check [README.worker.md](https://github.com/benjamine/Roque/blob/master/Roque.Service/WorkerUtils/README.worker.md).\r\n\r\n## Features\r\n\r\n- Queues are persisted on Redis. Redis is *fast*, scalable and simple to set up. (Others storages can be plugged in)\r\n- Transparent integration. Just call your methods, raise your events. They already make your intent clear, no need for complex message routing configurations, *DRY*.\r\n- You keep your code strong-typed (compile-time checks, intellisense, refactoring) and completely agnostic of the queueing mechanism. \r\n- Jobs are stored as simple JSON objects that any person or app can read.\r\n- Scalability. If your queues are getting full, just start more workers. You can have multiple distributed worker instances picking jobs from the same queue, work load gets balanced. Workers can be added or removed at any time. Multiple publishers are supported too.\r\n- On workers, service classes are resolved using IoC, so you can easy swap implementations.\r\n- Run on console (useful for debugging) or as a windows service.\r\n- Built-in support for resuming jobs. If a worker is shut down unexpectedly, when restarted it will retry the same job.\r\n- Configure retrying rules (time to wait before retrying, max number of times) based on Exception types.\r\n- Minimal latency. By using Redis no polling is done, jobs are pushed immediately to the first available worker. pushing and popping is *fast* (Redis LPUSH / BRPOPLPUSH based).\r\n- Monitor queue status, and check when queues are getting too long (need more workers?), or jobs are getting too old (workers are down or disconnected?).\r\n- Run workers on a separate AppDomain.\r\n  - Hot deploy. Roque restarts workers automatically if any *.config or *.dll is changed.\r\n  - Memory size monitoring. Roque can restart automatically when memory size consumed by workers exceeds a limit (detect and prevent memory leaks).\r\n- Supports 2 message queue patterns:\r\n  - Work queues (by invoking methods). eg. request the execution of a job asynchronously.\r\n  - Message broadcasting (pub/sub) in front of work queues (by raising events). eg. notify multiple subscriptors that perform jobs on specific events.\r\n- Scheduled triggers. Set schedules on workers to enqueue specific jobs. \r\n  - Supports cron syntax\r\n  - Configure schedules on multiple workers to get redundancy. Only one job will be enqueued each time.\r\n  - Optionally, a parameter for the invoked method can be specified in config (in JSON format)\r\n\r\n## Queue Patterns\r\n\r\nRoque supports 2 type of queues:\r\n\r\n### Work Queue\r\n\r\n<img src=\"https://raw.github.com/benjamine/Roque/master/mq_work.png\" alt=\"work queue\"/>\r\n\r\nThis type of queue is used when you directly invoke a method in a proxy (check Example 1)\r\n\r\n- (P)roducer here is a dynamic proxy built using: ```RoqueProxyGenerate.Create<IMyService>(\"queuename\");```\r\n- A message is sent to the queue on each method invocation\r\n- queues are redis lists\r\n- (C)consumer are Roque Workers that instantiate a service class (implementing IMyService), can be run on console or a window service instance.\r\n\r\n### Pub/Sub (in front of Work Queues)\r\n\r\n<img src=\"https://raw.github.com/benjamine/Roque/master/mq_pubsub_work.png\" alt=\"pub/sub queue\"/>\r\n\r\nHere a new actor appears to introduce decoupling between producer and consumers, this what we want when we create events in C#.\r\nSo this type of queue is used when raise events that are observed by a RoqueEventBroadcaster. (check Example 2)\r\n\r\n- (P)roducer here is a RoqueEventBroadcaster object that's subscribed to specific events in your app: ```new RoqueEventBroadCaster().HandleEvents<MyInterfaceWithEvents>(objectImplementingMyInterfaceWithEvents);```\r\n- A message is sent to the queue each time the event raises (only if there are subscribers listening)\r\n- (B)roadcaster, as you may guess, your RoqueEventBroadCaster object. He copies the message to each queue where there's a subscriber waiting. On Redis a SortedSet of subscribed queues is maintained for each specific C# event you subscribe to. Subscriber sets are cached by broadcaster and on any change they get notified in realtime using a Redis PUB/SUB message. \r\n- Once the message is copied into each queue all continues as in a Work Queue (each subscribed queue is a Work Queue)\r\n\r\n## Retrying\r\n\r\nIf a job fails (either in a work service class or an event handler provided by a subscriber class) Roque allows you to specify if the Worker should retry to execute it.\r\n\r\n### RetryOnAttribute\r\n\r\n``` csharp\r\n\r\n    // (on all class methods) if the thumbnails file server is down, keep retrying until someone fix it\r\n    [RetryOn(typeof(ThumbnailsFileServerNotFoundExceptin), DelaySeconds=30, MaxTimes=100)]\r\n    public class ImageProcessor : IImageProcessor {\r\n        public void CreateThumbnail(string filename, int width, int height, AlgorithmOptions options = null){\r\n            // a time-consuming task, eg: resize the image and save it adding a suffix\r\n            throw new NotImplementedException();\r\n        }\r\n    }\r\n``` \r\n\r\n### DontRetryOnAttribute\r\n\r\n``` csharp\r\n\r\n    // always retry any method if unexpected exceptions occur\r\n    [RetryOn(typeof(ThumbnailsFileServerNotFoundExceptin), DelaySeconds=30)]\r\n    public class ImageProcessor : IImageProcessor {\r\n\r\n        // if the original file is not found, the user must have deleted the image, don't retry\r\n        [DontRetryOn(typeof(FileNotFoundExceptin))]\r\n        public void CreateThumbnail(string filename, int width, int height, AlgorithmOptions options = null){\r\n            // a time-consuming task, eg: resize the image and save it adding a suffix\r\n            throw new NotImplementedException();\r\n        }\r\n    }\r\n```\r\n\r\nPlease note:\r\n\r\n- These attribute can be specified at method or class level\r\n- Multiple attributes can be applied (exception types are compared with the \"is\" operator from top to bottom like in catch {} blocks)\r\n- by default jobs are never retried\r\n\r\n## Benchmarks\r\n\r\nOn a very preliminar and simple benchmark with this conditions:\r\n\r\n- 100K messages (jobs/tasks/events).\r\n- Running Redis, publisher and workers on a single machine.\r\n- An almost zero-effort job (we just want to test the engine)\r\n\r\nWe got:\r\n\r\n- Enqueueing ~ 47.6K jobs per second\r\n- Dequeueing with 1 worker ~ 4.6K jobs per second\r\n- Dequeueing with 3 workers ~ 9.9K jobs per second \r\n\r\nNote: Dequeuing speed can be increased by adding more workers (and eventually more Redis clusters).Although running multiple workers on same machine doesn't make a lot of sense, a more significant improvement would come from running workers on different machines.\r\n\r\n## License\r\n\r\n(The MIT License)\r\n\r\nCopyright (c) 2012 Cinchcast <contact@cinchcast.com>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n","google":"UA-36008134-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Roque","tagline":"event & work queueing framework for .Net"}